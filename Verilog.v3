pipeline_v
module pipeline_cpu (
    input clk
);

    // Instruction memory (4 instructions)
    reg [7:0] instr_mem [0:3];
    reg [1:0] pc;

    // Register file
    reg [7:0] regfile [0:3];
    reg [7:0] data_mem [0:3];

    // Pipeline registers
    reg [7:0] IF_ID;
    reg [7:0] ID_EX;
    reg [7:0] EX_WB;

    integer i;

    // Initialize memory
    initial begin
        instr_mem[0] = 8'b00011001; // ADD R1, R2, R1
        instr_mem[1] = 8'b01010010; // SUB R1, R0, R2
        instr_mem[2] = 8'b10001100; // LOAD R0, mem[0]
        instr_mem[3] = 8'b00000000;

        regfile[0] = 8'd10;
        regfile[1] = 8'd5;
        regfile[2] = 8'd2;
        regfile[3] = 8'd0;

        data_mem[0] = 8'd20;
        data_mem[1] = 8'd30;
    end

    // IF Stage
    always @(posedge clk) begin
        IF_ID <= instr_mem[pc];
        pc <= pc + 1;
    end

    // ID Stage
    always @(posedge clk) begin
        ID_EX <= IF_ID;
    end

    // EX Stage
    always @(posedge clk) begin
        case (ID_EX[7:6])
            2'b00: EX_WB <= regfile[ID_EX[3:2]] + regfile[ID_EX[1:0]]; // ADD
            2'b01: EX_WB <= regfile[ID_EX[3:2]] - regfile[ID_EX[1:0]]; // SUB
            2'b10: EX_WB <= data_mem[ID_EX[1:0]];                     // LOAD
            default: EX_WB <= 8'd0;
        endcase
    end

    // WB Stage
    always @(posedge clk) begin
        regfile[ID_EX[5:4]] <= EX_WB;
    end

endmodule

pipeline_tb

module pipeline_cpu_tb;

reg clk;

pipeline_cpu uut (.clk(clk));

always #5 clk = ~clk;

initial begin
    clk = 0;
    #60 $finish;
end

endmodule
